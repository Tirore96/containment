Containment proofs can be reduced to showing there exists a coercion from one type to the other.
Should this coercion be written in gallina or DSL?
The difference is Gallina allows coerions that does not preserve the underlying string, which is bad.
For any bad coercion, there exists a good coercion interpreted from our DSL, so we do not lack expressivity in proving containments from coercions
Could make sense from a usability point of view. The dsl is awkward to program in

Coercive subtyping vs subsubptive subtyping:
Subsumptive way destroys canonicity, bad for subtyping in type theory. Not relevant for our application
Coercive approach is good for effeciency, for a typing s : T, we can always retrieve string by flatten(s). 
This is not the case for subsumptive way, s : T is weaker, it means exists T', T <= T for which s : T (without use of subsumption rule), to retrieve s, we must determine T', traversing the derivation of s : T, flatten(s) is no longer linear

Is this in any way related to mailbox programming: specifying the inbox by a regular expression?


From induxctive to coinductive dsl:
Benefit of no exotic terms.
Being mixed inductive/coinductive, termination of interpretation can be shown by induction.
Inconvenient as a programming language. Possibly ineffecient for decision procedure certifying containment with coercion 
Can be related to inductive syntax ala unraveling if necessary

Inductive syntax uses binders from autosubst disallowing intrinsically typed terms, 
would complicate interpretation, as a proof of well-typedness must be interpeted to coerion.
By the fix rule, the typing rule would necessarily be coinductive (or inductive with explicit visited list maybe?) 
Intrinsic typing allows stating the coercion system faithfully to Henglein & Nielsen,
reordering their judgment c : E <= F, to E <= F ~> c, let's us compactly state the judgment simply as
P c, where (c : dsl E F).

Hmmm.
The coercion system is a type system, but we use intrinsic typing, so why do we care about the coercion system?
Our dsl is our coercion system

Accidentally implemented equi-recursion by translating star to list without any fold/unfold operations.
Although parse trees become smaller, matching them to their regular expressions can involve backtracking
since sum rules can be confused with fold
Actually there is not confusion with sum rules because proof terms inl T and cons a T are distinct, but
it lets us express the empty string as nil and tt, which is bad. Why is it important we avoid this?

Shallow vs deep embedding of regex as types
The shallow approach of as_type(r) has reached it's limit, cannot compute the size of a parse_tree 
because it is not an inductive definition.
Replace as_type(r) with (T : treeOf r), solving the issue

Intrsinsically typed dsl vs coercion system:
The coercion system restricts the shape of the dsl, otherwise using fx counters, the dsl itself might
be too expressive. What's an example of a program that's not derivable in coercion system?
There is no example, I have proved that all programs can be derived.
The coercion system is defined with paco, which disallows the judgment from living in Type.
Using Coq's Coinductive directive instead and switching from Prop to Type, directly yields our intrinsicially typed dsl

Summation in equivalence rules:
Summation not necessary, should be removed

Why is intrinsic typing of dsl and parse trees important:
DSL programs are restricted to well-typed, making interpretation a total function on dsls
Using extrinsic typnig, the interpretation would be on a derivation of the dsl.
Derivation would need to be in Type.
We used both representations, extrinsic gave us the flexibility of writing a generator,
This let us go from Match to pTree


Soundness:
Use this trick: https://coq.inria.fr/doc/V8.18.0/stdlib/Coq.Logic.ConstructiveEpsilon.html
Maybe it doesn't work, it turns H : exists a, P a into {a | P a} type, we want to turn (H : Match s r) into (H' : parse R)

Alternative to constructive epsilon is to state Match in Type:
Explored this in syntax2.v
Got to coinductive characterization implies match equivalence, cannot destruct coinductive, it goes Prop,
if functor for gfp goes to Type, then universe inconsistency. This does not happen when using Coinductive to take fixpoint, only happens for paco fixpoint, which requires Type index to increase. Using coinductive directive that is not necessary. 
Can paco because used to take the gfp of a functor on Type?
Extrinsic typing is just doing the same thing thing in two steps, mapping each typing constructor 
to dsl constructor, allowing us to divorce syntax from meaningful programs.


Paper note:
A section discussing whether Match should be in Type or in Prop


Side idea:
Scoped de brujin captures openess of a term, could something similar be used for contractiveness?



Why do we need DSL?
Showing containment proofs corresponds to a trace-preserving 
gallina function on parse trees (indexed by regular expressions) is very quick.
This would be a characterization of containment with a single rule (f : [r] -> [r']) and (forall s, flat(s) = flat (f s))
We defined encode/decode functions betwen Match derivation and pTrees, so by completeness, f always exists 
when a containment is derivable. Decode has no practical use because it is terribly slow (encode is linear).
The point of the DSL is to synthesise effecient functions, by translating the coinductive proof steps
directly into a function, with use of decode!
Can a coinductive proof tree be translated to a typed dsl, or even directly interpreted?

extrinsically typed DSL:
Will be necessary for effeciently building DSL. Going from Prop to Type is computationally expensive, large search space,
Building coinductive DSL requires going through Prop, (unless we define Functor without paco, going to Type and decide membership in ot

Cannot find single argument for why we should use inductive dsl, it is not more effecient, we use inductive in session types because we need decidable equivalence

Interpretation:
Interpreting using as_types was easy, Coq understands the input type,
When using pTree r, pattern matching forgets this information, and we get unreachable cases,
using dependent destruction we can define intepretaitons interactively, but proof terms are huge (not effecient)

Intrinsic parse trees:
Being indexed by types, such as (p_inl r0 r1 p) they are not space effecient. Will not work when we go to bitcodings.
Instead have extrinsic parse trees and intrinsic dsl.
A main lemma is then forall (d : dsl r0 r1), with (interp p ) : upTree -> upTree, 
then typing p r0 -> typing (interp d p) r1  
Being extrinsic, interpreted dsls receving unexpected parse trees map to up_bot which is not typable

Interpretation:
A coinductive seed that is continously matched on is ineffecient because we might need log2 n (n being number of operations), to fetch relevant gallina function. It is fine as a spec, but we need something faster.
Does type indices in dsl affect performance?
Define interpretation of extrinsic dsl as [fix p] =  [p] : (pTree -> pTree) -> pTree -> pTree |- 
[fix. trans shuffle 0] : 
[shuffle] : ?
[0] : =
[trans shuffle 0] = f : (nat -> pTree -> pTree) -> pTree -> pTree 

f f

f f' T = T

Declaring variables Parameters is important for deleting them from code extraction.


They use equi-recursion in the bit coding case

Implementation:
This paper has zero-cost coercions
https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/coercible.pdf?from=https://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/coercible.pdf&type=exact

Haskell bitlibrary:
https://hackage.haskell.org/package/bitvec



Extra work:
Consider implementing unfolding interpretation anyways and see code extraction and evaluate.
Maybe not interesting as unfolding is expensive for large nested fixpoints


Summary:
We want to synthesize coercions.
Therefore no coinductive syntax for dsl (cannot be synthesised)
binders generated with autosubst disallows dsl with regex indices, so extrinsic dsl (coercion system)
Therefore extrinsic parse trees (interpreter does not have access to input/output regex types)

We want to synthesize effecient coercions.
Interpretation with unfolding is ineffecient, pattern matching and unfolding is repeated.
Interpretation without unfolding is challenging, one approach that could handle nested fixpoint interpeted
effeciently is:

interp : coerce r0 r1 -> r0 -> r1

interp : dsl (pT -> pT) -> pT -> pT

[.] : (pT -> pT) -> pT -> pT
f = interp [p]
f : (pT -> pT) -> pT -> pT
fix f : pT -> pT

f = inter p
fix f
interp [fix f. p]

interp : dsl -> 
        (forall p, (nat -> forall p', |p'| < |p| -> pT) -> pT) ->
         (forall p, (nat -> forall p', |p'| < |p| -> pT) -> pT) 



This is complicated because we work with open terms

For now, we keep unfolding interpretation
Write the function graph, do structural recursion on graph



Discussion with Fritz:
- Unfolding interpretation is ineffecient
- Bitcoding is equi-recursive
- sum rule not necessary
- Programming languages with coercive subtyping?
- Rules like drop take linear time



Discussion notes:
- star ctx and eps eliminiation rules are fixpoints themselves,
  cannot be coded using our fix rule, because it is "obviously terminating"
  Fix rule + two "hardcoded" fixpoints is enough to derive r = o(r) + sigma ....
  Think more about these rules, realizing they are fixpoints themselves,
  does this change the way they can be presented?

- Two notions of guarded
 * full_unf d <> cfix ...
 * variable occurs only inside guard (*allows decreasing measure*)
 Maybe the second notion could replace the first,
 but that would mean changing the proof of full_unf_idemp

- Type deriven interpretation vs untyped
 * untyped reduces number of parameters
   complicates inductive definition of domain
   nested call in transitivity, domain of this call
   has two restrictions
   ** size of T may not increase
   ** for well typed dsl and input parse tree, the
      domain 

- untyped interpretation:
  Trying to define inductive domain loosely in the transitivity case
  This does not work, the purpose of T in inductive domain
  is to resolve +, following T, will let the dsl
  bottom out in a base rule eventually
  
  Defining the inductive domain to permissively, means it can never be derived,
  and the function never called


- Not gonna do it, but it would be interesting to do a type driven interpretation,
  mapping typing derivations to typing derivations.
  More cases in the computation graph could be omitted: But then 
  coercions map type derivations to type derivations, meaning we could easily just have
  intrinsically typed parse trees, but since the dsl is still extrinisically typed 
  maybe INEQ judgments need to be added in the computation graph? sounds messy

- It seems bragga method does not work with nested 
  structural recursion on parse tree. 
  With the proof (H: D_dom (Star c) T) 
  we now structurally recurse on T,
  actually, the pattern matches just need to be on D_dom syntax
  rather than parse tree. Of course we cannot, because that would be Prop -> Set,
  or what, since we go to Prop -> Type maybe fine?
  
