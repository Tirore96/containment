Regular expressions are typically studied in automata and formal language theory as a formalism for denoting the class of regular languages, where the only observable property is whether a string belongs to the denoted set of strings or not, and any two regular expressions are observably equivalent if they satisfy the same membership tests.  In programming practice, however, regular expressions are typically used to extract more detailed information: not only whether but also how a string matches a regular expression, ranging from extracting a particular substring to constructing a full parse tree.  Many automata theory techniques are inapplicable in this setting; for example, a deterministic finite automaton constructed from a regular expression provides no way of constructing a parse tree for the given regular expression.  

It is known that proofs of membership of strings in (the language denoted by) a regular expression are in one-to-one correspondence to parse trees; and that a formal proof of a regular expression containment $A \leq B$ in an axiomatization of regular expression containment can be operationally interpreted as a coercion, a function that maps any proof of containment of a string in $A$ into a proof of containment of the same string in $B$.  Different containment proofs may yield extensionally different functions, however, since regular expressions, considered as grammars, can be ambiguous. Additionally, even if extensionally the same, one proof of containment may yield a slow implementation, another an efficient one.
This raises the questions: How do we synthesize not only any proof of containment, but a provably efficient one, if one exists at all?  How can we perform this synthesis itself efficiently?  More fundamentally, how do we even know that the containment axiomatization at hand contains not only inefficient coercions?

In this paper we prove that provably efficient coercions can be synthesized efficiently and mechanize this result in Coq, along with soundness (only terminating coercions are inferred) and completeness (for each valid containment at least one  coercion is derivable). As part of the solution to synthesis, we also introduce a technique for mechanized decidability of regular expression containment and equivalence admitting a coercion interpretation of proofs in under 900 lines of code. 
Finally we extract our efficient coercion synthesis procedure and benchmark the performance of the synthesized coercions.  More speculatively, we propose that the interaction between domain-specific language design, functional programming, and computational complexity analysis on the one hand and mechanizated axiomatization on the other hand may provide a productive methodology for efficient domain-specific software design and synthesis--even in the case where mechanized formal correctness is not the key objective.
